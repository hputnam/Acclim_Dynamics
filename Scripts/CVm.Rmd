---
title: "CVm.Rmd"
author: "EL Strand"
date: "6/7/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(plyr)
library(dplyr)
library(ggplot2)
library(robustbase)
```

# CVm - Physiology 

Selecting variables: protein, TAC, Host AFDW, Ratio AFDW, Chl (5). 

Chlorophyll and Sym AFDW are overlapping on PCAs [here](https://github.com/hputnam/Coral_Stress_Phenome/blob/main/CSP-Results-Update.md) from the 'Multivariate_PCA.R' script. Remove Sym AFDW because this value is also considered in the Ratio AFDW variable. 

Might have to exclude another variable..   
Re-do this when we have cell counts. 


Reading in meta and data frames. 
```{r}
meta <- read.csv("Output/results_physiology.csv")
  meta$Timepoint <- factor(meta$Timepoint, levels = c("Day 1", "Day 2", "1 week", "2 week", "4 week", "6 week", "8 week", "12 week", "16 week"))
meta$Group <- paste(meta$Timepoint, meta$Treatment, meta$Species, sep = "_") # create groups so that CVm fxn can run on each group
  
meta <- meta[complete.cases(meta), ] #only taking complete cases 

Mcap <- meta %>% subset(Species == "Mcapitata")
Pact <- meta %>% subset(Species == "Pacuta")

Mcap.meta <- Mcap %>% select(Site.Name:CO2)
Mcap.data <- Mcap %>% select(chla.ug.cm2, prot_mg.cm2, Ratio_AFDW.mg.cm2)

Pact.meta <- Pact %>% select(Site.Name:CO2)
Pact.data <- Pact %>% select(chla.ug.cm2, prot_mg.cm2, Ratio_AFDW.mg.cm2)
```

Center and scale the dataframes. 

Do you have to center and scale each group? Should it be part of the fore loop below? On PCA you don't center and scale each group b/c then not comparable.. 
Do poc and mont need to be center and scaled together to be comparable?

```{r}
# Center and scaling variables
Mcap.data.scaled <- scale(Mcap.data, center = T, scale = T) 
Pact.data.scaled <- scale(Pact.data, center = T, scale = T) 

# Creating scaled variables into dataframe again
Mcap.data.scaled.df <- as.data.frame(Mcap.data.scaled)
Pact.data.scaled.df <- as.data.frame(Pact.data.scaled)

# Adding plug ID back in to be merged with meta below 
Mcap.data.scaled.df$Plug_ID <- Mcap$Plug_ID
Pact.data.scaled.df$Plug_ID <- Pact$Plug_ID

# Merging with metadata; take out original data  
Mcap.CVm <- Mcap %>% select(Site.Name:CO2) %>% full_join(Mcap.data.scaled.df, by="Plug_ID")
Pact.CVm <- Pact %>% select(Site.Name:CO2) %>% full_join(Pact.data.scaled.df, by="Plug_ID")
```

Defining the CVm function based on Tanner et al 2018 and Albert et al 2010. 
```{r}
CVm <- function(data) {
  n<-dim(data)[1]
  p<-dim(data)[2]
  
  # MCD estimates
  #    =============
  mcd <- covMcd(data,alpha=0.75,cor=T,use.correction=T)
  mean <- mcd$center # Mean
  s <- mcd$cov       # Covariance matrix
  
  # CVm approached based on Tanner at al 2018 
  CVm <- sqrt((t(mean)%*%s%*%mean)/(t(mean)%*%mean)^2)*100
  # Standard error of CVm
  CVm2 <- CVm/100
  SE.CVm <- CVm2/sqrt(2*n)*sqrt(1+2*CVm2^2)*100
  
  rslt<-list()
  rslt$mean <- mean           # MCD mean
  rslt$s <- s                 # MCD covariance matrix
  rslt$CVm <- CVm             # Tanner et al: CVm
  rslt$SE.CVm <- SE.CVm       # Tanner et al: Standard error of CVm
  return(rslt)
}
```

Applying the CVm function above to all the individual groups. 

Error come back to - if the 's' table in the CVm fxn contains all negative values, then the CV calculation produces an NA value. 
```{r}
# Combining Mcap and Pacuta back together after analyzing separately 
# Grouping by group name and adding a sample size column 
all.CVm <- union(Mcap.CVm, Pact.CVm) %>% group_by(Group, .add = TRUE) %>% dplyr::mutate(count = n()) %>%
  filter(count > 4)

# Separating dataframes based on the group column (results in 56 new dataframes; i.e. CVm[[1]])
# This function does this by the Group_by function above alphabetically 
CVm.split <- all.CVm %>% group_split() 

# selecting only the data column in each df in the all.CVm list 
CVm.data <- lapply(CVm.split, '[', c(11:13))

# apply the CVm function to all dataframes within the all.CVm list 
CVm.Results <- lapply(CVm.data, CVm)

## Testing the CVm function on individual dataframes 
# `df.4 week_ATHC_Pacuta` <- `df.4 week_ATHC_Pacuta` %>% select(11:13)
# CVm(`df.4 week_ATHC_Pacuta`)
```

Creating a dataframe from the results of CV function above. 
```{r}
df <- data.frame(Reduce(rbind, CVm.Results))

# selecting only the Group column to create a one column df ordered alphabetically to match the order of the group_split() function
Group.names <- all.CVm[order(all.CVm$Group), 6]
Group.names <- distinct(Group.names) # removing duplicate rows

# rename the rows to the previous group names 
df$Group <- Group.names$Group
```

Example of results from CVm function when the result is negative. 

[[1]]
[[1]]$mean
      chla.ug.cm2       prot_mg.cm2 Ratio_AFDW.mg.cm2 
      -0.43813754       -0.06654211       -0.19536512 

[[1]]$s
                  chla.ug.cm2 prot_mg.cm2 Ratio_AFDW.mg.cm2
chla.ug.cm2         -6.658572   -6.956759          3.258124
prot_mg.cm2         -6.956759  -14.315236          1.585549
Ratio_AFDW.mg.cm2    3.258124    1.585549         -2.553795

[[1]]$CVm
     [,1]
[1,]  NaN

[[1]]$SE.CVm
     [,1]
[1,]  NaN



# CVm - Gene Expression

```{r}
# CVm_GE <- rep(0, 5)
# CVmSE_GE <- rep(0,5)
# 
# for (i in 1:5) {
#   subset <- subset(adGEt_labels, Treatment == treatments[i])
#   subset$Treatment <- NULL
#   #subset <- data.frame(sapply(subset, function(x) as.numeric(as.character(x))))
#   tran.data <- log10(subset)
#   m<-colMeans(tran.data) # Mean
#   s<-var(tran.data)      # Covariance matrix
#   #remove rows and columns that have only NAs
#   
#   n<-dim(tran.data)[1]   # Sample size
#   CVm<-sqrt((t(m)%*%s%*%m)/(t(m)%*%m)^2)*100 
#   CVm2 <- CVm/100
#   CVm_GE[i]<- CVm2
#   CVmSE_GE[i]<-CVm2/sqrt(2*n)*sqrt(1+2*CVm2^2)*100        # Standard error
# }
# 
# 
# # MCD estimates
#   #    =============
#   mcd<-covMcd(data,alpha=0.75,cor=T,use.correction=T)
#   mean<-mcd$center # Mean
#   s<-mcd$cov       # Covariance matrix
#   
#   # The new approach CVm
#   CVm<-sqrt((t(mean)%*%s%*%mean)/(t(mean)%*%mean)^2)*100
#   # Standard error of CVm
#   CVm2<-CVm/100
#   SE.CVm<-CVm2/sqrt(2*n)*sqrt(1+2*CVm2^2)*100
#   
#   rslt<-list()
#   rslt$mean<-mean           # MCD mean
#   rslt$s<-s                 # MCD covariance matrix
#   rslt$CVm<-CVm             # Tanner et al: CVm
#   rslt$SE.CVm<-SE.CVm       # Tanner et al: Standard error of CVm
#   return(rslt)
```




